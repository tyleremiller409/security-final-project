//===- exceptions.dl --------------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module takes care of symbolization in the exception sections and
it generates CFI directives based on the unwind and exception information.
*/

/**
A CIE can be associated to multiple FDEs and it contains information common to all
of them. 'CieAddr' uniquely identifies the CIE.
*/
.decl cie_entry(CieAddr: address,Length:unsigned,CodeAlignmentFactor:unsigned,DataAlignmentFactor:number)
.input cie_entry

/**
`cie_encoding` complements `cie_entry` and defines the encodings of the pointers in the FDEs and in the
LSDAs associated to this CIE.
*/
.decl cie_encoding(CieAddr: address,FdeEncoding:unsigned,LsdaEncoding:unsigned)
.input cie_encoding

/**
The personality routine associated to a CIE entry. This is the procedure that takes care of unwinding
the stack and exceptions. For C++ it is typically: '__gxx_personality_v0'.
*/
.decl cie_personality(CieAddr:address,Personality:address,PersonalityPos:address,PersonalitySize:unsigned,Encoding:unsigned)
.input cie_personality

/**
A FDE entry defines how stack unwinding is done in a region of code from 'start' to 'end'.
Each FDE points to a parent CIE that contains properties common to multiple FDEs.
'FdeAddr' and 'Length' determine the location of the FDE entry in the eh_frame section.
A FDE entry can have 'Lsda' associated that contains exception handling information.
*/
.decl fde_entry(FdeAddr: address,Length:unsigned,Cie:address,Start:address,End:address,Lsda:address)
.input fde_entry

/**
Ancillary predicate that specifies the actual locations of the symbolic expressions
in the FDE entry.
*/
.decl fde_pointer_locations(addr:address,startLocation:address,endLocation:address,
                            endSize:unsigned,lsdaLocation:address,lsdaSize:unsigned)
.input fde_pointer_locations

/**
The instructions for stack unwinding are encoded into a dwarf program
formed by a list of instructions. Each FDE corresponds to a region
in the code and it has its own program. This predicate captures
one instruction in that program.

- FdeAddr is the address of the FDE and indentifies it uniquely.
- Index identifies the instruction within the FDE uniquely.
- Size is the size of the instruction in bytes.
- InsnAddr is the address where the instruction is located
- Insn is the actual opcode of the instruction
- Op1 and Op2 are the operands of the instruction.

*/
.decl fde_instruction(FdeAddr:address,Index:unsigned,Size:unsigned,InsnAddr:address,Insn:symbol,Op1:number,Op2:number)
.input fde_instruction

/**
A LSDA defines the exception information of a region of code (typically a procedure).
This is located in section '.gcc_except_table'. A LSDA entry contains two main elements
a callsite table (see `lsda_callsite`) and a type table (see `lsda_type_entry`).
*/
.decl lsda(lsdaAddress:address,callsiteTable:address,callsiteTableEncoding:unsigned,callSiteTableLength:unsigned,
           typeTable:address,typeTableEncoding:unsigned,landingPadBaseAddress: address)
.input lsda

/**
Complementary predicate with the locations of the various pointers in a LSDA used for symbolization.
*/
.decl lsda_pointer_locations(lsdaAddress:address,typeTablePointerLocation:address,callsiteTablePointerLoc:address)
.input lsda_pointer_locations

/**
The range [Start,End) corresponds to the try block
and 'LandingPad' to the location where the catch block is located.
'EA_start', 'EA_end' and 'EA_landingPad' a the locations of the symbolic expressions
in the .gcc_except_table that point to 'Start', 'End' and 'LandingPad' respectively.
*/
.decl lsda_callsite(CallSiteTable_address:address,EA_start:address,Start:address,
    EA_end:address,End:address,
    EA_landingPad:address,LandingPad:address,EA_endLandindPad:address)
.input lsda_callsite

/**
The exception handling mechanism chooses which catch block catches an given exception
based on the type of the exception. This is done by having references to the types
which are encoded in the type table.
A `lsda_type_entry` is an entry in the type table. The "type" is represented as a
symbolic expression pointing to 'address'.
*/
.decl lsda_type_entry(lsdaTypeTableAddress:address,index:unsigned,address:address)
.input lsda_type_entry
/////////////////////////////////////////////////////////////////////////////////
// output predicates

/**
A CFI directive specifies unwind information directly inlined into the assembly code.
This representation is slightly higher level than a raw eh_frame section but mostly equivalent.
Most CFI directives are generated 1-to-1 from a `fde_instruction`.
Other CFI directives mark the beginning and end of the FDE (.starproc and .endproc)
or contain a pointer to the corresponding LSDA (exception handling information) or to the
personality (.cfi_lsda and .cfi_personality respectively).
*/
.decl cfi_directive(BlockAddress:address,Offset:unsigned,LocalIndex:unsigned,
                    directive:symbol,ReferenceSym:symbol,Nargs:unsigned,arg1:number,arg2:number)
.output cfi_directive

/**
`symbol_special_encoding` marks symbols that are encoded with uleb128 or sleb128.
*/
.decl symbol_special_encoding(EA:address,encoding:symbol)
.output symbol_special_encoding

/////////////////////////////////////////////////////////////////////////////////
// Extract information important for disassembly
.decl fde_addresses(start:address, end:address)
.output fde_addresses

fde_addresses(Start,End):-
    fde_entry(_,_,_,Start,End,_).

// The fde addresses restricted to existing blocks
.decl fde_block_addresses(FdeAddr:address,StartAddr:address,EndAddr:address)

fde_block_addresses(FdeAddr,Start,EndAddr):-
    fde_entry(FdeAddr,_,_,Start,EndAddr,_),
    refined_block(Start),
    block_information(_,_,EndAddr).

fde_block_addresses(FdeAddr,Start,EndBlock):-
    fde_entry(FdeAddr,_,_,Start,EndAddr,_),
    refined_block(Start),
    // this case moves the end address to the end of the last block
    !block_information(_,_,EndAddr),
    after_end(EndAddr,End),
    refined_block_last_instruction(Block,End),
    block_information(Block,_,EndBlock).

.decl lsda_callsite_addresses(Start:address,End:address,LandingPad:address)

lsda_callsite_addresses(Start,End,LandingPad):-
    lsda_callsite(_,_,Start,_,End,_,LandingPad,_).


labeled_ea(Lsda):-
    fde_entry(_,_,_,_,_,Lsda),
    Lsda != 0.

labeled_ea(Personality):-
    cie_personality(_,Personality,_,_,_),
    Personality != 0.

/////////////////////////////////////////////////////////////////////////////////
// Symbols in lsda

// type table pointer
symbol_special_encoding(TypeTablePointerLocation,"uleb128"),
symbol_minus_symbol(TypeTablePointerLocation,Size,CallsiteTablePointerLoc-1,LsdaTypeTableAddress,1,0):-
    lsda_pointer_locations(Lsda,TypeTablePointerLocation,CallsiteTablePointerLoc),
    lsda(Lsda,_,_,_,LsdaTypeTableAddress, _, _),
    LsdaTypeTableAddress != 0,
    Size = (CallsiteTablePointerLoc-1) - TypeTablePointerLocation,
    Size > 0.

//callsite table size
symbol_special_encoding(CallsiteTablePointerLoc,"uleb128"),
symbol_minus_symbol(CallsiteTablePointerLoc,Size,CallSiteTable_address,CallSiteTable_address+CallSiteTableLength,1,0):-
    lsda_pointer_locations(Lsda,_,CallsiteTablePointerLoc),
    lsda(Lsda,CallSiteTable_address,_,CallSiteTableLength,_, _, _),
    Size = CallSiteTable_address - CallsiteTablePointerLoc,
    Size > 0.

/////////////////////////////////////////////////////////////////////////////////
// Symbols in lsda callsite table

symbol_special_encoding(EA_start,EncodingName),
symbol_special_encoding(EA_end,EncodingName),
symbol_special_encoding(EA_landingPad,EncodingName):-
    lsda_callsite(CallSiteTable_address,EA_start,_,EA_end,_,EA_landingPad,_,_),
    lsda(_,CallSiteTable_address,CallSiteEncoding,_,_,_,_),
    special_encoding(Encoding,EncodingName),
    CallSiteEncoding band 0xF = Encoding.


//region beginning
symbol_minus_symbol(EA_start,Size,LandingPadBaseAddress,StartRegion,1,0):-
    lsda_callsite(CallSiteTable_address, EA_start, StartRegion,EA_end,_,_,_,_),
    lsda(_,CallSiteTable_address,_,_,_,_,LandingPadBaseAddress),
    Size = EA_end-EA_start,
    Size > 0.

//region end
boundary_sym_expr(EA_end,EndRegion),
symbol_minus_symbol(EA_end,Size,StartRegion,EndRegion,1,0):-
    lsda_callsite(_, _, StartRegion,EA_end,EndRegion,EA_landingPad,_,_),
    Size = EA_landingPad-EA_end,
    Size > 0,
    // Boundary is at the end of the block preceding the EndRegion label.
    block_boundaries(_,_,EndRegion).

//landing pad
symbol_minus_symbol(EA_landingPad,Size,LandingPadBaseAddress,LandingPad,1,0):-
    lsda_callsite(CallSiteTable_address, _, _,_,_,EA_landingPad,LandingPad,EA_endLandingPad),
    lsda(_,CallSiteTable_address,_,_,_,_,LandingPadBaseAddress),
    LandingPad != 0,
    Size = EA_endLandingPad-EA_landingPad,
    Size > 0.

///////////////////////////////////////////////////////////////////////////////
// Symbols in lsda typetable
symbolic_data(EAType,EncodingSize,Type):-
    lsda_type_entry(LsdaTypeTableAddress, Index,Type),
    lsda(_,_,_,_,LsdaTypeTableAddress, TypeTableEncoding, _),
    TypeTableEncoding band 0xF = Encoding,
    TypeTableEncoding band 0x10 = 0,
    dwarf_encoding_size(Encoding,EncodingSize),
    EAType=LsdaTypeTableAddress-(EncodingSize*(Index+1)),
    Type != 0.

symbol_minus_symbol(EAType,EncodingSize,EAType,Type,1,0):-
    lsda_type_entry(LsdaTypeTableAddress, Index,Type),
    lsda(_,_,_,_,LsdaTypeTableAddress, TypeTableEncoding, _),
    TypeTableEncoding band 0xF = Encoding,
    TypeTableEncoding band 0x10 > 0,
    dwarf_encoding_size(Encoding,EncodingSize),
    EAType=LsdaTypeTableAddress-(EncodingSize*(Index+1)),
    Type != 0.

////////////////////////////////////////////////////////////////////////////////
// cie symbols

// cie size
symbol_minus_symbol(Addr,4,Addr+4,Addr+Length+4,1,0):-
    option("no-cfi-directives"),
    cie_entry(Addr,Length,_,_).

// personality
symbol_special_encoding(PersonalityPos,EncodingName):-
    option("no-cfi-directives"),
    cie_personality(_,Personality,PersonalityPos,_,PersonalityEncoding),
    Personality != 0,
    special_encoding(Encoding,EncodingName),
    PersonalityEncoding band 0xF = Encoding.

symbolic_data(PersonalityPos,Size,Personality):-
    option("no-cfi-directives"),
    cie_personality(_,Personality,PersonalityPos,Size,_),
    Personality != 0.

/////////////////////////////////////////////////////////////////////////////////
// fde symbols

// fde size
symbol_minus_symbol(Addr,4,Addr+4,Addr+Length+4,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,Length,_,_,_,_),
    !last_fde(Addr).

symbol_minus_symbol(Addr,4,Addr+4,EndSection,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,_, _, _,_),
    last_fde(Addr),
    loaded_section(_,EndSection,".eh_frame").

// CIE offset
symbol_minus_symbol(Addr+4,4,Cie,Addr+4,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,Cie, _, _,_).

// Begin pointer
symbol_special_encoding(StartLocation,EncodingName),
symbol_special_encoding(EndLocation,EncodingName):-
    option("no-cfi-directives"),
    fde_pointer_locations(Addr,StartLocation,EndLocation,_,_,_),
    fde_entry(Addr,_,Cie,_,_,_),
    cie_encoding(Cie,FdeEncoding,_),
    special_encoding(Encoding,EncodingName),
    FdeEncoding band 0xF = Encoding.


symbolic_data(StartLocation,EndLocation-StartLocation,StartFunction):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,Cie, StartFunction, _,_),
    cie_encoding(Cie,FdeEncoding,_),
    // absolute encoding
    FdeEncoding band 0x10 = 0,
    fde_pointer_locations(Addr,StartLocation,EndLocation, _,_,_).

symbol_minus_symbol(StartLocation,EndLocation-StartLocation,StartLocation,StartFunction,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,Cie, StartFunction, _,_),
    cie_encoding(Cie,FdeEncoding,_),
    // pc-relative encoding
    FdeEncoding band 0x10 > 0,
    fde_pointer_locations(Addr,StartLocation,EndLocation, _,_,_),
    EndLocation-StartLocation > 0.


// end pointer
symbol_minus_symbol(EndLocation,EndSize,StartFunction,EndFunction,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,_, StartFunction, EndFunction,_),
    fde_pointer_locations(Addr,_,EndLocation, EndSize,_,_),
    EndSize > 0.

// lsda pointer
symbol_special_encoding(LsdaLocation,EncodingName):-
    option("no-cfi-directives"),
    fde_pointer_locations(Addr,_,_, _,LsdaLocation,_),
    fde_entry(Addr,_,Cie, _, _,_),
    cie_encoding(Cie,_,LsdaEncoding),
    special_encoding(Encoding,EncodingName),
    LsdaEncoding band 0xF = Encoding.

symbolic_data(LsdaLocation,LsdaSize,LsdaAddress):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,Cie, _, _,LsdaAddress),
    fde_pointer_locations(Addr,_,_, _,LsdaLocation,LsdaSize),
    LsdaSize > 0,
    cie_encoding(Cie,_,LsdaEncoding),
    // absolute encoding
    LsdaEncoding band 0x10 = 0.

symbol_minus_symbol(LsdaLocation,LsdaSize,LsdaLocation,LsdaAddress,1,0):-
    option("no-cfi-directives"),
    fde_entry(Addr,_,Cie, _, _,LsdaAddress),
    fde_pointer_locations(Addr,_,_, _,LsdaLocation,LsdaSize),
    LsdaSize > 0,
    cie_encoding(Cie,_,LsdaEncoding),
    // pc-relative enconding
    LsdaEncoding band 0x10 > 0.


// instructions
symbol_minus_symbol(InstructionAddr+1,Size-1,Addr+(AdvanceUnsigned*CodeAlignmentFactor),Addr,CodeAlignmentFactor,0):-
    option("no-cfi-directives"),
    fde_instruction(FdeAddr,Index,Size,InstructionAddr,"advance_loc",Advance,_),
    AdvanceUnsigned = as(Advance,unsigned),
    Size > 1,
    fde_instruction_ref(FdeAddr,Index,_,Addr),
    fde_entry(FdeAddr,_,Cie,_,_,_),
    cie_entry(Cie,_,CodeAlignmentFactor,_).

/////////////////////////////////////////////////////////////////
// Auxiliary predicates for symbols
.decl special_encoding(Code:unsigned,Name:symbol)

special_encoding(1,"uleb128").
special_encoding(9,"sleb128").

.decl dwarf_encoding_size(Encoding:unsigned,Size:unsigned)

// The encoding 0 is officially not defined but it happens
// in x86 32 bits programs. In that case, the encoding
// seems to be a regular 4 byte pointer.
dwarf_encoding_size(0,4).

dwarf_encoding_size(2,2).
dwarf_encoding_size(3,4).
dwarf_encoding_size(4,8).

dwarf_encoding_size(10,2).
dwarf_encoding_size(11,4).
dwarf_encoding_size(12,8).

.decl last_fde(Addr:address)

last_fde(Addr):-
    fde_entry(Addr,Length,_, _, _,_),
    !fde_entry(Addr+Length+4,_,_, _, _,_),
    !cie_entry(Addr+Length+4,_,_,_).

.decl last_fde_instruction(FdeAddr:address,Index:unsigned)

last_fde_instruction(FdeAddr,Index+1):-
    fde_instruction(FdeAddr,Index,_,_,_,_,_),
    !fde_instruction(FdeAddr,Index+1,_,_,_,_,_).

// location to which the instruction refers
.decl fde_instruction_ref(FdeAddr:address,Index:unsigned,LocalIndex:unsigned,ReferenceAddr:address)

// LocalIndex is 3 because the instruction comes after startproc, lsda and personality.
fde_instruction_ref(FdeAddr,0,3,StartFunction):-
    fde_entry(FdeAddr,_, _,StartFunction,_,_).

fde_instruction_ref(FdeAddr,Index+1,NextLocalIndex,Addr):-
    fde_instruction_ref(FdeAddr,Index,LocalIndex,Addr),
    fde_instruction(FdeAddr,Index,_,_,Insn,_,_),
    Insn != "advance_loc",
    Insn != "cf_advance_loc",
    (
        Insn = "nop", NextLocalIndex = LocalIndex
        ;
        Insn != "nop", NextLocalIndex = LocalIndex+1
    ).

fde_instruction_ref(FdeAddr,Index+1,0,Addr+(CodeAlignmentFactor*as(Advance,unsigned))):-
    fde_instruction_ref(FdeAddr,Index,_,Addr),
    fde_entry(FdeAddr,_,Cie,_,_,_),
    cie_entry(Cie,_,CodeAlignmentFactor,_),
    (
        fde_instruction(FdeAddr,Index,_,_,"advance_loc",Advance,_);
        fde_instruction(FdeAddr,Index,_,_,"cf_advance_loc",Advance,_)
    ).

.decl endproc_local_index(FdeAddr:address,LocalIndex:unsigned)

endproc_local_index(FdeAddr,LocalIndex):-
    fde_entry(FdeAddr,_, _,_,EndAddr,_),
    last_fde_instruction(FdeAddr,Index),
    (
        fde_instruction_ref(FdeAddr,Index,LastLocalIndex,Addr),
        Addr = EndAddr, LocalIndex = LastLocalIndex
        ;
        fde_instruction_ref(FdeAddr,Index,_,Addr),
        Addr != EndAddr, LocalIndex = 0
    ).


//////////////////////////////////////////////////////////////////////////////////
// Computation of cfi directives

// special directives

// only generate startproc and endproc together or none

cfi_directive(StartFunction,0,0,".cfi_startproc","",0,0,0),
cfi_directive(Block,BlockSize,LastLocalIndex,".cfi_endproc","",0,0,0):-
    !option("no-cfi-directives"),
    fde_block_addresses(FdeAddr,StartFunction, EndAddr),
    block_information(Block,BlockSize,EndAddr),
    endproc_local_index(FdeAddr,LastLocalIndex).


// only generate other directives if the block range was generated
cfi_directive(StartFunction,0,1,".cfi_lsda",LsdaSymbol,1,Encoding,0):-
    !option("no-cfi-directives"),
    fde_entry(FdeAddr,_,Cie,StartFunction,_,Lsda),
    fde_block_addresses(FdeAddr,_,_),
    cie_encoding(Cie,_,LsdaEncoding),
    (
        Lsda != 0, Encoding = as(LsdaEncoding,number),
        best_symexpr_symbol(Lsda,LsdaSymbol,"Beg")
        ;
        Lsda = 0, Encoding = 255,
        LsdaSymbol = "",
        LsdaEncoding = LsdaEncoding // avoid warning
    ).

cfi_directive(StartFunction,0,2,".cfi_personality",PersonalitySymbol,1,Encoding,0):-
    !option("no-cfi-directives"),
    fde_entry(FdeAddr,_,Cie,StartFunction,_,_),
    fde_block_addresses(FdeAddr,_,_),
    (
        cie_personality(Cie,Personality,_,_,PersonalityEncoding),
        Personality != 0, Encoding = as(PersonalityEncoding,number),
        best_symexpr_symbol(Personality,PersonalitySymbol,"Beg")
        ;
        cie_personality(Cie,Personality,_,_,_),
        Personality = 0,
        Encoding = 255,
        PersonalitySymbol = ""
    ).

// directives that correspond to an instruction
cfi_directive(Block,Offset,LocalIndex,CfiInsn,"",NOperands,ScaledOp1,ScaledOp2):-
    !option("no-cfi-directives"),
    fde_instruction(FdeAddr,Index,_,_,Insn,Op1,Op2),
    fde_entry(FdeAddr,_,Cie,_,_,_),
    fde_block_addresses(FdeAddr,_,EndBlockAddr),
    dwarf_to_cfi(Insn,NOperands,CfiInsn),
    cie_entry(Cie,_,_,DataAlignmentFactor),
    (
        !cfi_operand_is_register(Insn,1),
        ScaledOp1 = Op1*DataAlignmentFactor
        ;
        cfi_operand_is_register(Insn,1),
        ScaledOp1 = Op1
    ),
    (
        !cfi_operand_is_register(Insn,2),
        ScaledOp2 = Op2*DataAlignmentFactor
        ;
        cfi_operand_is_register(Insn,2),
        ScaledOp2 = Op2
    ),
    fde_instruction_ref(FdeAddr,Index,LocalIndex,Addr),
    (
        Addr >= EndBlockAddr,
        block_information(Block,Offset,EndBlockAddr)
        ;
        Addr < EndBlockAddr,
        code_in_refined_block(Addr,Block),
        Offset = Addr-Block
    ).


// instructions that are encoded as a block of bytes (because they don't have their own cfi directive)
cfi_directive(Block,Offset,LocalIndex,".cfi_escape","",Size,as(InstructionBytesAddr,number),0):-
    !option("no-cfi-directives"),
    fde_instruction(FdeAddr,Index,Size,InstructionBytesAddr,"unhandled_instruction",_,_),
    fde_block_addresses(FdeAddr,_,EndBlockAddr),
    fde_instruction_ref(FdeAddr,Index,LocalIndex,Addr),
    (
        Addr >= EndBlockAddr,
        block_information(Block,Offset,EndBlockAddr)
        ;
        Addr < EndBlockAddr,
        code_in_refined_block(Addr,Block),
        Offset = Addr-Block
    ).

/////////////////////////////////////////////////////////////////
// Auxiliary predicates for cfi directives

.decl cfi_operand_is_register(Insn:symbol,OpNumber:unsigned)

cfi_operand_is_register("def_cfa",1).
cfi_operand_is_register("def_cfa",2). //non-factored
cfi_operand_is_register("def_cfa_sf",1).
cfi_operand_is_register("def_cfa_offset",1).
cfi_operand_is_register("def_cfa_register",1).
cfi_operand_is_register("offset",1).
cfi_operand_is_register("offset_extended",1).
cfi_operand_is_register("offset_extended_sf",1).
cfi_operand_is_register("register",1).
cfi_operand_is_register("register",2).
cfi_operand_is_register("rel_offset",1).
cfi_operand_is_register("restore",1).
cfi_operand_is_register("restore_extended",1).
cfi_operand_is_register("return_column",1).
cfi_operand_is_register("same_value",1).
cfi_operand_is_register("undefined",1).
cfi_operand_is_register("val_offset",1).


.decl dwarf_to_cfi(DwarfInsn:symbol,OpNumber:unsigned,CfiInsn:symbol)


dwarf_to_cfi("def_cfa",2,".cfi_def_cfa").
dwarf_to_cfi("def_cfa_offset",1,".cfi_def_cfa_offset").
dwarf_to_cfi("def_cfa_offset_sf",1,".cfi_def_cfa_offset").
dwarf_to_cfi("def_cfa_register",1,".cfi_def_cfa_register").
dwarf_to_cfi("def_cfa_sf",2,".cfi_def_cfa").
dwarf_to_cfi("offset",2,".cfi_offset").
dwarf_to_cfi("offset_extended",2,".cfi_offset").
dwarf_to_cfi("offset_extended_sf",2,".cfi_offset").
dwarf_to_cfi("register",2,".cfi_register").
dwarf_to_cfi("remember_state",0,".cfi_remember_state").
dwarf_to_cfi("restore",1,".cfi_restore").
dwarf_to_cfi("restore_extended",1,".cfi_restore").
dwarf_to_cfi("restore_state",0,".cfi_restore_state").
dwarf_to_cfi("same_value",1,".cfi_same_value").
dwarf_to_cfi("undefined",1,".cfi_undefined").
dwarf_to_cfi("val_offset",2,".cfi_val_offset").
dwarf_to_cfi("val_offset_sf",2,".cfi_val_offset").
