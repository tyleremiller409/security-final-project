//===- main.dl ----------------------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This is the main module of the datalog disassembler.
The disassembly has 3 main components:
 1- code_inference.dl
    -code_inference_postprocess.dl
    -cfg.dl
 2- symbolization.pl
    - use_def_analysis.dl
    - value_analysis.dl
    - data_access_analysis.dl
    - pointer_reatribution.dl

In addition there are several modules that consider special cases,
generic components and tables.

Special cases:
    -relative_jump_tables.dl

Generic components:
    -ordered_set.dl
    -empty_range.dl

Tables:
    -float_operations.dl
    -jump_operations.dl

This module:
- defines the input generated by the decoder
- defines a series of auxiliary predicates and basic facts that are used everywhere.
- defines some hard-code parameters of the analysis, such as the code and data sections
  explored.
*/

.type register <: symbol

.type address <: unsigned
.type operand_code <: unsigned
.type operand_index <: unsigned

// Binary format specific predicates.
#include "binary/elf/elf_binaries.dl"
#include "binary/pe/pe_binaries.dl"

// Architecture specific predicates.
#include "arch/arch.dl"

// Binary data
#include "data.dl"

// Detection of jump tables.
#include "jump_tables.dl"
#include "relative_jump_tables.dl"

// Inference of instruction boundaries.
#include "code_inference.dl"

// Infer special symbols and select symbols for symbolic expressions.
#include "symbols.dl"
// Performs literal-reference disambiguation and string inference.
#include "symbolization.dl"

// Inference of function boundaries.
#include "basic_function_inference.dl"

// Predicates for debugging and statistics.
#include "debug_stats.dl"
#include "self_diagnose.dl"
/////////////////////////////////////////////////////////////
// Inputs generated by the decoder
/////////////////////////////////////////////////////////////

// metadata
.decl entry_point(ea:address)
.input entry_point

.decl endianness(End:symbol) // Either LE or BE
.input endianness

.decl base_address(ea:address)
.input base_address

.decl symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)
.input symbol

.decl section(Name:symbol,Size:unsigned,EA:address,Align:unsigned,Index:unsigned)
.input section

.decl section_property(Name:symbol,Property:symbol)
.input section_property

.decl section_type(Name:symbol,Type:unsigned)
.input section_type

.decl relocation(EA:address,Type:symbol,Name:symbol,Addend:number,SymbolIndex:unsigned,Section:symbol,RelType:symbol)
.input relocation

.decl relocation_size(Type:symbol,Size:unsigned)

/**
Defines adjustments to relocation values.
*/
.decl relocation_adjustment(EA:address,Adjustment:number,Reason:symbol)
.output relocation_adjustment
/**
The total relocation adjustment for a location
*/
.decl relocation_adjustment_total(EA:address,Adjustment:number)
.output relocation_adjustment_total

relocation_adjustment_total(EA,0):-
    relocation(EA,_,_,_,_,_,_),
    !relocation_adjustment(EA,_,_).

relocation_adjustment_total(EA,Adjustment):-
    relocation(EA,_,_,_,_,_,_),
    Adjustment = sum N:{relocation_adjustment(EA,N,_)}.

.decl binary_type(Type:symbol)
.input binary_type

.decl binary_format(Format:symbol)
.input binary_format

.decl binary_isa(isa:symbol)
.input binary_isa

.decl option(Option:symbol)
.input option

.decl dynamic_entry(tag:symbol, value:unsigned)
.input dynamic_entry

// instructions

.decl instruction(ea:address,size:unsigned,prefix:symbol,opcode:symbol,
          op1:operand_code,op2:operand_code,op3:operand_code,op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction

/**
 The instruction at EA has capstone's cs_arm.writeback set.
*/
.decl instruction_writeback(EA:address)
.input instruction_writeback

/**
The register Register is accessed at EA with Mode.
Mode may be "R" or "W"
*/
.decl register_access(EA:address,Mode:symbol,Register:register)
.input register_access

.decl op_register_bitfield(code:operand_code,register_name:register)
.input op_register_bitfield

.decl invalid_op_code(ea:address)
.input invalid_op_code

// three kinds of operators
.decl op_regdirect(code:operand_code,register_name:register)
.input op_regdirect

.decl op_fp_immediate(code:operand_code,imm:float)
.input op_fp_immediate

.decl op_immediate(code:operand_code,offset:number)
.input op_immediate

.decl op_special(code:operand_code,type:symbol,value:symbol)
.input op_special
.output op_special

.decl op_indirect(code:operand_code,reg1:register,reg2:register,reg3:register,
        multiplier:number,offset:number,size_value:unsigned)
.input op_indirect

/**
The operand identified by Index should be shifted.

Used on ARM/ARM64, but not x86 or MIPS. Type is architecure-dependent.
*/
.decl op_shifted(EA:address,Index:unsigned,Shift:unsigned,Type:symbol)
.input op_shifted

/**
The operand identified by Index should be shifted.

Used on ARM/ARM64, but not x86 or MIPS. Type is architecure-dependent.
*/
.decl op_shifted_w_reg(EA:address,Index:unsigned,Reg:register,Type:symbol)
.input op_shifted_w_reg
.output op_shifted_w_reg

/**
There is a potential address at 'EA' pointing to 'Value'.
*/
.decl address_in_data(EA:address,Value:address)
.input address_in_data

// known data regions
.decl data_region(Begin:address,Size:unsigned)
.input data_region

/**
Possible null-terminated ASCII string of 'Size' bytes begins at address 'EA'.
*/
.decl ascii_string(EA:address,End:address)
.input ascii_string

///////////////////////////////////////////////////////////////
// Initialize components

.init function_inference = basic_function_inference

/////////////////////////////////////////////////////////////
// auxiliary definitions
/////////////////////////////////////////////////////////////

/**
This predicate determines the `Offset` and `Size` of an immediate operand of index `Index`.
This is used to place symbolic expressions at the right address.
The `Offset` is non-zero only for the x86 ISA, for other ISAs the symbolic
expressions point to the beginning of the instruction.
*/
.decl instruction_immediate_offset(EA:address,Index:operand_index,Offset:unsigned,Size:unsigned)
.output instruction_immediate_offset

instruction_immediate_offset(EA,Index,ImmediateOffset,Size-ImmediateOffset):-
    instruction(EA,Size,_,_,_,_,_,_,ImmediateOffset,_),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,_).

/**
This predicate determines the `Offset` and `Size` of a displacement
in an indirect operand of index `Index`.
This is used to place symbolic expressions at the right address.
The `Offset` is non-zero only for the x86 ISA, for other ISAs the symbolic
expressions point to the beginning of the instruction.
*/
.decl instruction_displacement_offset(EA:address,Index:operand_index,Offset:unsigned,Size:unsigned)
.output instruction_displacement_offset

instruction_displacement_offset(EA,Index,DisplacementOffset,DispSize):-
    instruction(EA,Size,_,_,_,_,_,_,ImmediateOffset,DisplacementOffset),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,_,_,_,_,_,_),
    (
        // x86 can have 'mov [Disp], Imm' (move immediate value to memory)
        // x86 encoding puts the immediate after the displacement so we need to
        // check the immediate offset to compute the size of the displacement
        ImmediateOffset > DisplacementOffset,
        DispSize = ImmediateOffset - DisplacementOffset,
        // avoid warning
        Size = Size
        ;
        ImmediateOffset <= DisplacementOffset,
        DispSize = Size - DisplacementOffset
    ).

.decl instruction_get_operation(ea:address,operation:symbol) inline

instruction_get_operation(EA,Operation):-
    instruction(EA,_,_,Operation,_,_,_,_,_,_).

.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)

instruction_get_op(EA,Index,Op):-
    instruction(EA,_,_,_,Op1,Op2,Op3,Op4,_,_),
    (
        Op1 != 0,
        Op = Op1, Index = 1,
        Op2 = Op2, Op3 = Op3, Op4 = Op4 // avoid warning
        ;
        Op2 != 0,
        Op = Op2, Index = 2,
        Op1 = Op1, Op3 = Op3, Op4 = Op4 // avoid warning
        ;
        Op3 != 0,
        Op = Op3, Index = 3,
        Op1 = Op1, Op2 = Op2, Op4 = Op4 // avoid warning
        ;
        Op4 != 0,
        Op = Op4, Index = 4,
        Op1 = Op1, Op2 = Op2, Op3 = Op3 // avoid warning
    ).


.decl instruction_get_dest_op(ea:address,index:operand_index,op:operand_code)

instruction_get_dest_op(EA,1,Op):-
    arch.store_operation(Operation),
    instruction(EA,_,_,Operation,Op,_,_,_,_,_),
    !arch.memory_access(_,EA,_,_,_,_,_,_,_).

instruction_get_dest_op(EA,DstIndex,Op):-
    arch.memory_access(_,EA,_,DstIndex,_,_,_,_,_),
    instruction_get_op(EA,DstIndex,Op).

instruction_get_dest_op(EA,Index,Op):-
    instruction(EA,_,_,Operation,_,Op2,Op3,Op4,_,_),
    !arch.store_operation(Operation),
    !arch.memory_access(_,EA,_,_,_,_,_,_,_),
    !arch.read_only_operation(Operation),
    (
        Op4 = 0,
        Op3 = 0,
        Op2 != 0,
        Op = Op2,
        Index = 2
        ;
        Op4 = 0,
        Op3 != 0,
        Op = Op3,
        Index = 3,
        Op2 = Op2 // avoid warning
        ;
        Op4 != 0,
        Op = Op4,
        Index = 4,
        Op2 = Op2, Op3 = Op3 // avoid warning
    ).

instruction_get_dest_op(EA,1,Op):-
    instruction(EA,_,_,Operation,Op,0,0,0,_,_),
    arch.one_op_write(Operation).

.decl instruction_get_src_op(ea:address,Index:operand_index,op:operand_code)

instruction_get_src_op(EA,2,Op):-
    arch.store_operation(Operation),
    instruction(EA,_,_,Operation,_,Op,0,0,_,_),
    !arch.memory_access(_,EA,_,_,_,_,_,_,_).

instruction_get_src_op(EA,SrcIndex,Op):-
    arch.memory_access(_,EA,SrcIndex,_,_,_,_,_,_),
    instruction_get_op(EA,SrcIndex,Op).

//when the dest is used as a source as well
instruction_get_src_op(EA,Index,Op2):-
    instruction(EA,_,_,Operation,_,Op2,_,_,_,_),Op2 != 0,
    Index = 2,
    !arch.mov(EA),
    !arch.memory_access(_,EA,_,_,_,_,_,_,_),
    !arch.op_does_not_read_dest_reg(Operation),
    !arch.write_only_operation(Operation).

instruction_get_src_op(EA,Index,Op):-
    (
        instruction(EA,_,_,Operation,Op,_,_,_,_,_), Op != 0, Index = 1;
        instruction(EA,_,_,Operation,_,Op,Op3,_,_,_), Op != 0, Op3 != 0, Index = 2;
        instruction(EA,_,_,Operation,_,_,Op,Op4,_,_), Op != 0, Op4 != 0, Index = 3
    ),
    !arch.memory_access(_,EA,_,_,_,_,_,_,_),
    !arch.store_operation(Operation),  // Currently not all archs fully implement arch.memory_access.
    !arch.write_only_operation(Operation).


/////////////////////////////////////////////////////////////
// inference of basic facts
/////////////////////////////////////////////////////////////

.decl next(n:address,m:address)

next(EA,EA+Size):-
    instruction(EA,Size,_,_,_,_,_,_,_,_).

.decl pc_relative_operand(src:address,index:operand_index, dest:address)
.output pc_relative_operand

pc_relative_operand(EA,Index,Dest):-
    binary_isa("X64"),
    instruction_get_op(EA,Index,Op),
    op_indirect(Op,"NONE",Reg,"NONE",1,Offset,_),
    arch.pc_register(Reg),
    next(EA,EANext),
    Dest = as(as(EANext,number)+Offset,address),
    !instruction_has_relocation(EA,_).

pc_relative_operand(EA,Index,Dest):-
    binary_isa("X64"),
    instruction_displacement_offset(EA,Index,Offset,_),
    relocation(EA+Offset,"PC32",_,Addend,SymbolIndex,_,_),
    symbol(Base,_,"SECTION",_,_,_,_,SymbolIndex,_),
    instruction(EA,Size,_,_,_,_,_,_,_,_),
    Dest = Base + as(as(Size-Offset,number)+Addend,unsigned).

.decl split_load_operand(src:address,index:operand_index, dest:address)
.output split_load_operand

split_load_operand(0,0,0):- false.

.decl instruction_has_loop_prefix(EA:address)

instruction_has_loop_prefix(EA):-
    instruction(EA,_,Prefix,_,_,_,_,_,_,_),
    arch.loop_prefix(Prefix).

/**
Instruction at address "EA" has a relocation for address "Relocation".
*/
.decl instruction_has_relocation(EA:address,Rel:address)
.output instruction_has_relocation

instruction_has_relocation(EA,EA+Offset):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    (
        instruction_immediate_offset(EA,_,Offset,_);
        instruction_displacement_offset(EA,_,Offset,_)
    ),
    relocation(EA+Offset,_,_,_,_,_,_).

// JUMPS
.decl unconditional_jump(n:address)

unconditional_jump(EA):-
    arch.jump(EA),
    !arch.conditional(EA,_).

.decl conditional_jump(src:address)

conditional_jump(EA):-
    arch.jump(EA),
    arch.conditional(EA,_).

// direct jumps
.decl direct_jump(src:address, dest:address)
.output direct_jump

direct_jump(EA,as(Dest,address)):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest),
    !instruction_has_relocation(EA,_).

direct_jump(EA,as(Dest,address)):-
    arch.jump(EA),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    defined_symbol(Dest,_,_,_,_,_,_,SymbolIndex,_).

direct_jump(EA,EA):-
    instruction_has_loop_prefix(EA).

.decl impossible_jump_target(EA:address)

impossible_jump_target(0):-
    false.

// Special kinds of indirect jumps
// PC relative jumps
.decl pc_relative_jump(src:address, dest:address)
.output pc_relative_jump

pc_relative_jump(EA,Dest):-
    arch.jump(EA),
    pc_relative_operand(EA,1,Dest).

// jump to the address of a register
.decl reg_jump(src:address,Reg:symbol)

reg_jump(EA,Reg):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect(TargetOp,Reg),
    !arch.pc_register(Reg).

// indirect jump
.decl indirect_jump(src:address)

indirect_jump(EA):-
    arch.jump(EA),
    instruction_get_operation(EA,Operation),
    arch.jump_operation_op_index(Operation,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_indirect(TargetOp,_,_,_, _,_,_),
    !pc_relative_jump(EA,_).

// CALLS
// direct calls
.decl direct_call(EA:address,Dest:address)
.output direct_call

direct_call(EA,as(Dest,address)):-
    arch.call(EA,Index),
    instruction_get_op(EA,Index,Op),
    op_immediate(Op,Dest),
    !instruction_has_relocation(EA,_).

direct_call(EA,Dest):-
    arch.call(EA,_),
    instruction_immediate_offset(EA,_,_,_),
    instruction_has_relocation(EA,Rel),
    relocation(Rel,_,_,_,SymbolIndex,_,_),
    defined_symbol(Dest,_,_,_,_,_,_,SymbolIndex,_).

.decl pc_relative_call(src:address,dest:address)
.output pc_relative_call

pc_relative_call(Src,Dest):-
    arch.call(Src,_),
    pc_relative_operand(Src,1,Dest).

// for now we do not compute anything about these
.decl reg_call(src:address,reg:register)
.output reg_call

reg_call(EA,Reg):-
    arch.call(EA,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_regdirect(TargetOp,Reg).

.decl indirect_call(src:address)
.output indirect_call

indirect_call(EA):-
    arch.call(EA,TargetOpIndex),
    instruction_get_op(EA,TargetOpIndex,TargetOp),
    op_indirect(TargetOp,_,_,_,_,_,_),
    !pc_relative_call(EA,_).

/**
Identify edge case direct calls that are used to load the program counter and
not as control-flow (e.g. call-to-pop sequences).
*/
.decl pc_load_call(Src:address,Dest:address)
.output pc_load_call

// TODO: Replace with platform-specific definition of direct_call.
pc_load_call(Src,Dest):-
    (
        binary_isa("X86");
        binary_isa("X64")
    ),
    // CALL pushes program counter to stack,
    direct_call(Src,Dest),
    // POP loads program counter from the stack.
    next(Src,Dest),
    instruction_get_operation(Dest,"POP").

// Returns
.decl return(n:address)

return(EA):-
    arch.return_operation(Operation),
    instruction_get_operation(EA,Operation).

.decl halt(EA:address)

halt(EA):-
    arch.halt_operation(Operation),
    instruction_get_operation(EA,Operation).

/**
Information about alignment in bits for a given address
*/
.decl alignment(EA:address,AlignInBits:unsigned)
.output alignment

alignment(0,0):- false.

//////////////////////////////////////////////////////////////////////////////////
// Operations to abstract features of instructions

.decl op_indirect_contains_reg(op:operand_code,reg:register)
.output op_indirect_contains_reg

// we ignore segment registers
op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,Reg2,_,_,_,_),
    arch.track_register(Reg2,Reg_uniform).

op_indirect_contains_reg(Op,Reg_uniform):-
    op_indirect(Op,_,_,Reg3,_,_,_),
    arch.track_register(Reg3,Reg_uniform).

.decl op_regdirect_contains_reg(op:operand_code,reg:register)
.output op_regdirect_contains_reg

op_regdirect_contains_reg(Op,Reg_uniform):-
    (
        op_regdirect(Op,Reg)
        ;
        op_register_bitfield(Op,Reg)
    ),
    arch.track_register(Reg,Reg_uniform).

// The instruction at EA has operation Operation and two operands: a register Reg and an immediate Immediate
.decl op_immediate_and_reg(EA:address,Operation:symbol,Reg:register,Imm_index:operand_index,Immediate:number)

op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate):-
    instruction_get_operation(EA,Operation),
    instruction_get_op(EA,Imm_index,Op),
    op_immediate(Op,Immediate),
    instruction_get_op(EA,_,Op2),
    op_regdirect_contains_reg(Op2,Reg).

// The instruction at EA is a comparison between a register Reg and an immediate Immediate
.decl cmp_immediate_to_reg(EA:address,Reg:register,Imm_index:operand_index,Immediate:number)

cmp_immediate_to_reg(EA,Reg,Imm_index,Immediate):-
    op_immediate_and_reg(EA,Operation,Reg,Imm_index,Immediate),
    arch.cmp_operation(Operation),
    (
        !arch.jump(EA);
        arch.jump(EA), arch.jump_operation_op_index(Operation,JumpTargetIndex), Imm_index != JumpTargetIndex
    ).

/////////////////////////////////////////////////////////////////////////////////

.decl symbol_set(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,name:symbol)

symbol_set(EA,Size,Type,Scope,Visibility,SectIndex,Name):-
    symbol(EA,Size,Type,Scope,Visibility,SectIndex,_,_,Name).

.decl ambiguous_symbol(name:symbol)
.output ambiguous_symbol

ambiguous_symbol(Name):-
    symbol_set(_,_,_,_,_,_,Name),
    1 < count :{symbol_set(_,_,_,_,_,_,Name)}.

// Function symbols
.decl function_symbol(ea:address,name:symbol)
.output function_symbol

function_symbol(EA,Name):-
    symbol(EA,_,"FUNC",_,_,_,_,_,Name).

function_symbol(EA,Name):-
    symbol(EA,_,"GNU_IFUNC",_,_,_,_,_,Name).

.decl defined_symbol(ea:address,size:unsigned,type:symbol,scope:symbol,visibility:symbol,sectionIndex:unsigned,originTable:symbol,tableIndex:unsigned,name:symbol)

defined_symbol(EA,Size,Type,Scope,Visibility,SectIndex,OriginTable,TableIndex,Name):-
    symbol(EA,Size,Type,Scope,Visibility,SectIndex,OriginTable,TableIndex,Name),
    // In executables, the section index can be irrelevant
    // so we check whether the symbol has non-zero address too.
    (SectIndex != 0; EA != 0),
    // Avoid most special section indexes
    // See https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-94076.html#chapter6-tbl-16
    (
        SectIndex < 0xff00; // SHN_LORESERVE
        SectIndex = 0xfff1; // SHN_ABS
        SectIndex > 0xffff  // SHN_HIRESERVE
    ),
    // Avoid FILE symbols.
    Type != "FILE".

////////////////////////////////////////////////////////////////////////////////////////

.decl loaded_section(Beg:address,End:address,Name:symbol)
.output loaded_section
.decl data_section(name:symbol)
.output data_section
.decl exception_section(name:symbol)
.decl special_data_section(name:symbol)
.decl regular_data_section(name:symbol)
.decl code_section(name:symbol)
.output code_section
.decl tls_section(name:symbol)
.output tls_section
.decl bss_section(name:symbol)
.output bss_section

loaded_section(Beg,Beg+Size,Name):-
    section(Name,Size,Beg,_,_),
    section_property(Name,"Loaded").

code_section(Section):-
    section(Section,_,_,_,_),
    section_property(Section,"Executable").

tls_section(Section):-
    data_section(Section),
    section_property(Section,"ThreadLocal").

regular_data_section(Name):-
    data_section(Name),
    !special_data_section(Name).

.decl non_zero_data_section(name:symbol)
.output non_zero_data_section

.decl bss_section_limits(Begin:address,End:address)
.output bss_section_limits

bss_section_limits(0,0):-
    !bss_section(_).

bss_section_limits(Begin,End):-
    Begin = min X:{ bss_section(Name),loaded_section(X,_,Name)},
    End = max X:{ bss_section(Name),loaded_section(_,X,Name)}.

/*
data segments can be data sections or fragments of the code section that
contain data instead of code.
*/

.decl initialized_data_segment(Begin:address,End:address)
.output initialized_data_segment

initialized_data_segment(Begin,End):-
    non_zero_data_section(Section),
    loaded_section(Begin,End,Section).

initialized_data_segment(Begin,End):-
    data_in_code(Begin,End).

.decl data_segment(Begin:address,End:address)

data_segment(Begin,End):-
    data_section(Section),
    loaded_section(Begin,End,Section).

data_segment(Begin,End):-
    initialized_data_segment(Begin,End).

////////////////////////////////////////////////////////////////////////////
// detect references  to libraries (calls to plt)
.decl plt_block(block:address,function:symbol)
.output plt_block

.decl got_reference(Got_entry:address,Symbol:symbol)
.output got_reference


.decl main_function(ea:address)

.decl conditional_return(EA:address)

conditional_return(EA):-
    arch.return(EA),
    arch.conditional(EA,_).

.decl unconditional_return(EA:address)

unconditional_return(EA):-
    arch.return(EA),
    !arch.conditional(EA,_).


/**
Detects non-returning calls before even must/may fallthrough relations.

Calculated even before code inference.
*/
.decl no_return_call(EA:address)

.decl function_pointer_section(Name:symbol)

.decl no_return_function(Name:symbol)

no_return_call(EA):-
    direct_call(EA,Dest),
    plt_entry(Dest,Function),
    no_return_function(Pattern),
    match(Pattern,Function).

no_return_call(EA):-
    direct_call(EA,Dest),
    defined_symbol(Dest,_,_,_,_,_,_,_,Name),
    no_return_function(Pattern),
    match(Pattern,Name).

no_return_call(EA):-
    direct_call(EA,_),
    instruction_immediate_offset(EA,_,Offset,_),
    relocation(EA+Offset,_,_,_,SymbolIndex,_,_),
    symbol(_,_,_,_,_,_,_,SymbolIndex,Name),
    no_return_function(Pattern),
    match(Pattern,Name).

/**
Detect no-return calls after code inference, but before value analysis.
*/
.decl no_return_call_refined(EA:address)

no_return_call_refined(EA):-
    code(EA),
    no_return_call(EA).

no_return_call_refined(EA):-
    direct_call(EA,Dest),
    code(EA),
    plt_block(Dest,Function),
    no_return_function(Pattern),
    match(Pattern,Function).

.decl is_padding(EA:address)

is_padding(EA):-
    arch.is_nop(EA).

/**
The set of printable ASCII characters.
*/
.decl printable_char(N:unsigned)

printable_char(0x9).
printable_char(0xA).
printable_char(0xC).
printable_char(0xD).
printable_char(N):-
    N = range(0x20,0x7E+1,1).

/*
The functions and data-objects that are intrinsic to the compiler's ABI -
artifacts of compilation that are not explicit features of the source and
will likely be reintroduced by the compiler toolchain.
*/
.decl abi_intrinsic(EA:address,Name:symbol)
.output abi_intrinsic
