//===- relative_jump_tables.dl ------------------------------*- datalog -*-===//
//
//  Copyright (C) 2019 GrammaTech, Inc.
//
//  This code is licensed under the GNU Affero General Public License
//  as published by the Free Software Foundation, either version 3 of
//  the License, or (at your option) any later version. See the
//  LICENSE.txt file in the project root for license terms or visit
//  https://www.gnu.org/licenses/agpl.txt.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU Affero General Public License for more details.
//
//  This project is sponsored by the Office of Naval Research, One Liberty
//  Center, 875 N. Randolph Street, Arlington, VA 22203 under contract #
//  N68335-17-C-0700.  The content of the information does not necessarily
//  reflect the position or policy of the Government and no official
//  endorsement should be inferred.
//
//===----------------------------------------------------------------------===//
/**
This module deals exclusively with detecting jump tables with relative addresses.
*/

.decl take_address(Src:address,Address_taken:address)

take_address(Src,Address):-
    pc_relative_operand(Src,1,Address),
    instruction_get_operation(Src,"LEA").

/*
This detects potential jump tables even before any of the data analyses is performed.
It is used to find jump tables in the code section.

These jump tables seem to have entries of sizes 4 or 8 only.
Jump tables with entry sizes of 1 or 2 appear in data and can be detected later.

In these jump tables, the reference address coincides with the starting address
of the jump table.
*/
.decl relative_address(EA:address,Size:unsigned,TableStart:address,Reference:address,Dest:address,DestIsFirstOrSecond:symbol)
.output relative_address

.decl relative_address_start(EA:address,Size:unsigned,Reference:address,Dest:address, DestIsFirstOrSecond:symbol)

relative_address_start(EA,Size,EA,Dest,DestIsFirstOrSecond):-
    take_address(_,EA),
    EASigned = as(EA,number),
    data_word(EA,Size,Diff),
    Diff != 0,
    (binary_format("PE"); EA % Size = 0), // jump tables are assumed to be aligned
    // Check if the second entry is reasonable, too.
    // This is based on the assumption that a jump-table consists of multiple
    // entries.
    data_word(EA+Size,Size,Diff2),
    Diff2 != 0,
    // This is according to what we have seen generated by ICC
    (
        Size = 4, Diff <= 0, Diff2 <= 0
        ;
        Size = 8,
        // The read addresses are not regular pointers already
        !relocation(EA,_,_,_,_,_,_)
    ),
    // sometimes the jump table entry is Diff = Reference-JumpTarget
    // and sometimes it is Diff = JumpTarget-Reference
    (
        Dest = as(EASigned-Diff,address), DestIsFirstOrSecond = "second",
        Dest2 = as(EASigned-Diff2,address)
        ;
        Dest = as(EASigned+Diff,address), DestIsFirstOrSecond = "first",
        Dest2 = as(EASigned+Diff2,address)
    ),
    possible_ea(Dest),
    possible_ea(Dest2).

relative_address(EA,Size,EA,Ref,Dest,DestIsFirstOrSecond):-
    relative_address_start(EA,Size,Ref,Dest,DestIsFirstOrSecond).

relative_address(EA+Size,Size,TableStart,Ref,Dest,DestIsFirstOrSecond):-
    relative_address(EA,Size,TableStart,Ref,_,DestIsFirstOrSecond),
    data_word(EA+Size,Size,Diff),
    Diff != 0,
    RefSigned = as(Ref,number),
    (
        DestIsFirstOrSecond = "second", Dest = as(RefSigned-Diff,address),Size >= 4;
        DestIsFirstOrSecond = "first", Dest = as(RefSigned+Diff,address)
    ),
    possible_ea(Dest),
    !relative_address_start(EA+Size,_,_,_,_).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// detect jump tables precisely once we have all results of the analyses

// auxiliary predicate for detecting accessing an element of a jump table.
.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address,RegIndex:register,Mult:unsigned)

jump_table_element_access(EA,Size,TableStartAddr,RegIndex,Size):-
    data_access(EA,_,"NONE","NONE",RegIndex,as(Size,number),TableStart,Size),
    TableStartAddr = as(TableStart,address),
    RegIndex != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,1,TableStartAddr,RegBase,1):-
    data_access(EA,_,"NONE",RegBase,"NONE",_,TableStart,1),
    TableStartAddr = as(TableStart,address),
    RegBase != "NONE",
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

jump_table_element_access(EA,Size,TableStartAddr,RegIndex,Size):-
    data_access(EA,_,"NONE",RegBase,RegIndex,as(Size,number),Offset,Size),
    RegIndex != "NONE",
    const_value_reg_used(EA,_,_,RegBase,Base),
    TableStartAddr = as(Base+Offset,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

// sometimes the regBase contains the index (already multiplied)
// and the regIndex contains the base address
jump_table_element_access(EA,Size,TableStartAddr,RegBase,1):-
    data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
    RegBase != "NONE",
    const_value_reg_used(EA,_,_,RegIndex,TableStart),
    TableStartAddr = as(TableStart,address),
    data_segment(Beg,End),
    TableStartAddr >= Beg,
    TableStartAddr <= End.

/**
The end of a jump table as identified by a boundary value of the index register.
*/
.decl jump_table_max(TableStart:address,TableEnd:address)
.output jump_table_max

jump_table_max(TableStart,TableStart+as(Value,unsigned)*Mult):-
    jump_table_element_access(EA,_,TableStart,RegIndexRaw,Mult),
    arch.track_register(RegIndexRaw,RegIndex),
    code_in_block(EA,Block),
    last_value_reg_limit(Block,RegIndex,Value,"MAX"),
    Value >= 0.

.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)
.output jump_table_start

jump_table_start(EA_jump,Size,TableStart,as(Base,address),Scale):-
    // Looks like a jump table access occurs at EA...
    jump_table_element_access(EA,Size,TableStart,_,_),
    // ...and the register defined at EA (Reg) is used as RegJump = Base + Reg * Scale
    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
    Reg != "NONE",
    // ...and something jumps to that register.
    def_used(EA_add,RegJump,EA_jump,_),
    (
        reg_call(EA_jump,_);
        reg_jump(EA_jump,_)
    ),
    code(EA_jump).

//  mov REG, TableReference
//  add REG, SIZE PTR [_*Size+TableStart] OR sub REG, SIZE PTR [_*Size+TableStart]
//  jmp REG
jump_table_start(EA_jump,Size,TableStart,TableReferenceAddr,Scale):-
    reg_jump(EA_jump,_),
    code(EA_jump),
    def_used(EA_base,Reg,EA_jump,_),
    instruction_get_operation(EA_base,Operation),
    (
        Operation = "ADD", Scale=1;
        Operation = "SUB", Scale=-1
    ),
    jump_table_element_access(EA_base,Size,TableStart,_,_),
    const_value_reg_used(EA_base,_,_,Reg,TableReference),
    TableReferenceAddr = as(TableReference,address),
    (
        code(TableReferenceAddr);
        TableStart=TableReferenceAddr
    ).

// mov EAX,DWORD PTR [ECX+EAX*4+.L_804a008@GOTOFF]   load
// add EAX,ECX                                       base
// jmp EAX                                           jump
jump_table_start(EA_jump,4,TableStart,TableReference,1):-
    binary_isa("X86"),
    got_reference_pointer(TableReference),
    // Load offset.
    got_relative_operand(EA_load,1,TableStart),
    def_used(EA_load,Reg_got,EA_base,_),
    // Base is GOT.
    arch.reg_reg_arithmetic_operation(EA_base,Reg_jump,Reg_got,_,1,0),
    // Jump to register.
    def_used(EA_base,_,EA_jump,_),
    reg_jump(EA_jump,Reg_jump).

///////////////////////////////////////////////////////////////////////////////////////////////////////
// propagate jump tables

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale

These are generated during value analysis, and referenced by value analysis,
so cannot negate any results of value analysis.

Some of these are discarded to form relative_jump_table_entry, which is used by
symbolization.
*/
.decl relative_jump_table_entry_candidate(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.output relative_jump_table_entry_candidate

relative_jump_table_entry_candidate(TableStart,TableStart,Size,TableReference,Dest,Scale,0):-
    !binary_isa("ARM"),
    jump_table_start(_,Size,TableStart,TableReference,Scale),
    (
        Size > 1,data_word(TableStart,Size,Diff);
        Size = 1,data_byte(TableStart,DiffUnsigned), Diff = as(DiffUnsigned,number)
    ),
    TableReference_signed = as(TableReference,number),
    Dest = as(TableReference_signed + as(Scale,number)*Diff,unsigned),
    code(Dest),
    // The table is in a loaded section.
    loaded_section(SectionStart,SectionEnd,_),
    TableStart >= SectionStart, TableStart < SectionEnd.

// If we identified a limit to the size of the jump table using the boundary
// value analysis (jump_table_max), propagate it now and feed the result back
// into the value analysis.
// If a jump table is unbounded (i.e., no jump_table_max has been generated),
// then we have low confidence about its size. In this case, we defer
// propagating until the post-value-analysis refinement stage. Propagating
// unbounded tables would likely pollute value analysis results with
// questionable edges anyway.
//
// Propagate until finding:
// * jump table index boundary
// * something that doesn't resolve to a code pointer.
// * a symbol
// * the end of a data section

relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    !binary_isa("ARM"),
    relative_jump_table_entry_candidate(LastEA,TableStart,Size,Reference,_,Scale,Offset),
    EA = LastEA + Size,
    jump_table_max(TableStart,TableEnd),
    TableEnd >= EA,
    !symbol(EA,_,_,_,_,_,_,_,_),
    data_segment(BegData,EndData), BegData <= TableStart, EA+Size <= EndData,
    (
        Size>1,data_word(EA,Size,Diff);
        Size=1,data_byte(EA,DiffUnsigned), Diff = as(DiffUnsigned,number)
    ),
    Reference_signed = as(Reference,number),
    Dest = as(Reference_signed + as(Scale,number)*Diff,unsigned),
    code(Dest).

.decl discarded_jump_table_entry(TableStart:address,TableRef:address,EA:address)
.output discarded_jump_table_entry

// Prefer jump tables where TableRef = TableStart, if there is a conflict.
discarded_jump_table_entry(TableStart,TableRef1,TableStart):-
    jump_table_start(_,_,TableStart,TableRef1,_),
    jump_table_start(_,_,TableStart,TableRef2,_),
    TableRef1 != TableStart,
    TableRef2 = TableStart.

// Truncate a jump table if a separate data access is encountered.
discarded_jump_table_entry(TableStart,Ref,EA):-
    relative_jump_table_entry_candidate(EA,TableStart,Size,Ref,_,_,_),
    possible_data_limit(Limit),
    EA <= Limit, Limit < EA+Size,
    EA != TableStart.

// Recursively discard
discarded_jump_table_entry(TableStart,Ref,EA):-
    discarded_jump_table_entry(TableStart,Ref,DiscardEA),
    jump_table_start(_,Size,TableStart,Ref,_),
    EA = DiscardEA + Size,
    relative_jump_table_entry_candidate(EA,TableStart,Size,Ref,_,_,_).

/**
An entry in a relative jump table of the form (Dest-Reference)/Scale.

These are generated after data access analysis, and used for symbolization and final
CFG generation. This allows using the final results of value analysis to
resolve overlapping jump tables.
*/
.decl relative_jump_table_entry(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.output relative_jump_table_entry

relative_jump_table_entry(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    relative_jump_table_entry_candidate(EA,TableStart,Size,Reference,Dest,Scale,Offset),
    !discarded_jump_table_entry(TableStart,Reference,EA).

/**
Propagate unbounded jump tables

Jump tables with no jump_table_max are not propagated in the
relative_jump_table_entry_candidate relation since we have low confidence on
their boundaries. We propagate them now, in the refinement stage, where we
can negate more advanced analyses.

Since these were not propagated earlier, these edges were not used during value
analysis.
*/
relative_jump_table_entry(EA,TableStart,Size,Reference,Dest,Scale,Offset):-
    !binary_isa("ARM"),
    relative_jump_table_entry(LastEA,TableStart,Size,Reference,_,Scale,Offset),
    !jump_table_max(TableStart,_),
    EA = LastEA + Size,
    !symbol(EA,_,_,_,_,_,_,_,_),
    data_segment(BegData,EndData), BegData <= TableStart, EA+Size <= EndData,
    (
        Size>1,data_word(EA,Size,Diff);
        Size=1,data_byte(EA,DiffUnsigned), Diff = as(DiffUnsigned,number)
    ),
    last_data_limit(EA+Size-1,LastDataLimit),LastDataLimit < EA,
    Reference_signed = as(Reference,number),
    Dest = as(Reference_signed + as(Scale,number)*Diff,unsigned),
    code(Dest).
